package client

import (
	"bytes"
	"context"
	_ "embed"
	"encoding/binary"
	"fmt"
	"image"
	"image/png"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/malashin/dds"
	"github.com/xackery/encdec"
	"github.com/xackery/quail-gui/gui"
	"github.com/xackery/quail-gui/gui/component"
	"github.com/xackery/quail-gui/ico"
	"github.com/xackery/quail-gui/slog"
	"github.com/xackery/quail/common"
	"github.com/xackery/quail/model/mesh/mds"
	"github.com/xackery/quail/model/mesh/mod"
	"github.com/xackery/quail/model/metadata/ani"
	"github.com/xackery/quail/model/metadata/lay"
	"github.com/xackery/quail/model/metadata/prt"
	"github.com/xackery/quail/model/metadata/pts"
	"github.com/xackery/quail/model/metadata/zon"
	"github.com/xackery/quail/pfs"
	"github.com/xackery/wlk/walk"
	"golang.org/x/image/bmp"
	"golang.org/x/image/draw"
)

type layerWrapper struct {
	Layers []*common.Layer
}

func (c *Client) inspect(file string) (interface{}, error) {
	if len(file) < 2 {
		slog.Printf("Inspecting %s\n", filepath.Base(c.currentPath))
	} else {
		slog.Printf("Inspecting %s %s\n", filepath.Base(c.currentPath), filepath.Base(file))
	}

	if len(file) < 2 {
		entries := []*component.FileViewEntry{}
		for _, fe := range c.pfs.Files() {
			ext := strings.ToLower(filepath.Ext(fe.Name()))
			fve := &component.FileViewEntry{
				Icon:    generateIcon(fe.Name(), fe.Data()),
				Name:    fe.Name(),
				Ext:     ext,
				Size:    generateSize(len(fe.Data())),
				RawSize: len(fe.Data()),
			}

			entries = append(entries, fve)
		}
		gui.SetFileViewItems(entries)
		return c.pfs, nil
	}
	return c.inspectFile(c.pfs, c.currentPath, file)
}

func (c *Client) inspectFile(pfs *pfs.PFS, path string, file string) (interface{}, error) {
	if pfs == nil {
		data, err := os.ReadFile(path)
		if err != nil {
			return nil, err
		}
		return c.inspectContent(filepath.Base(file), bytes.NewReader(data))
	}

	data, err := pfs.File(file)
	if err != nil {
		return nil, fmt.Errorf("pfs file %s: %w", file, err)
	}

	totalSize := len(data)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	go func() {
		totalMB := float64(totalSize) / 1024 / 1024
		if totalMB < 1 {
			return
		}

		gui.SetProgress(1)
		defer gui.SetProgress(0)

		// set sleep 100ms for every mb
		sleep := time.Duration(totalMB) * 100 * time.Millisecond

		// every 100ms set progress 10
		for i := 0; i < 10; i++ {
			time.Sleep(sleep)
			select {
			case <-ctx.Done():
				return
			default:
			}
			gui.SetProgress(10 * (i + 1))
		}
	}()
	return c.inspectContent(file, bytes.NewReader(data))
}

func (c *Client) inspectContent(file string, data *bytes.Reader) (interface{}, error) {
	var err error
	ext := strings.ToLower(filepath.Ext(file))
	gui.SetImage(nil)
	switch ext {
	case ".mds":
		model := common.NewModel(strings.TrimSuffix(strings.ToUpper(file), ".MDS"))
		err = mds.Decode(model, data)
		if err != nil {
			return nil, fmt.Errorf("mds.Decode %s: %w", file, err)
		}
		return model, nil
	case ".mod":
		model := common.NewModel(strings.ToUpper(file), ".MOD"))
		err = mod.Decode(model, data)
		if err != nil {
			return nil, fmt.Errorf("mod.Decode %s: %w", file, err)
		}
		return model, nil
	case ".pts":
		point := &common.ParticlePoint{
			Name: strings.TrimSuffix(strings.ToUpper(file), ".MDS"),
		}
		err = pts.Decode(point, data)
		if err != nil {
			return nil, fmt.Errorf("pts.Decode %s: %w", file, err)
		}
		return point, nil
	case ".prt":
		render := &common.ParticleRender{
			Name: strings.TrimSuffix(strings.ToUpper(file), ".MDS"),
		}
		err = prt.Decode(render, data)
		if err != nil {
			return nil, fmt.Errorf("prt.Decode %s: %w", file, err)
		}
		return render, nil
	case ".zon":
		zone := &common.Zone{
			Name: strings.TrimSuffix(strings.ToUpper(file), ".ZON"),
		}
		err = zon.Decode(zone, data)
		if err != nil {
			return nil, fmt.Errorf("zon.Decode %s: %w", file, err)
		}
		return zone, nil

	case ".ani":
		animation := &common.Animation{}
		err = ani.Decode(animation, data)
		if err != nil {
			return nil, fmt.Errorf("ani.Decode %s: %w", file, err)
		}
		return animation, nil
	//case ".lit":
	/*type lightWrapper struct {
		Lits []*common.RGBA
	}

	lw := &lightWrapper{}
	err = lit.Decode(lw.Lits, data)
	if err != nil {
		return nil, fmt.Errorf("lit.Decode %s: %w", file, err)
	}
	return lw, nil*/

	case ".lay":
		model := common.NewModel("")
		err := lay.Decode(model, data)
		if err != nil {
			return nil, fmt.Errorf("lay.Decode %s: %w", file, err)
		}
		return &layerWrapper{Layers: model.Layers}, nil
	case ".dds":
		img, err := dds.Decode(data)
		if err != nil {
			return nil, fmt.Errorf("dds.Decode %s: %w", file, err)
		}
		bmp, err := walk.NewBitmapFromImageForDPI(img, 96)
		if err != nil {
			return nil, fmt.Errorf("new bitmap from image for dpi: %w", err)
		}
		gui.SetImage(bmp)
		return nil, nil
	case ".png":
		img, err := png.Decode(data)
		if err != nil {
			return nil, fmt.Errorf("png.Decode %s: %w", file, err)
		}
		bmp, err := walk.NewBitmapFromImageForDPI(img, 96)
		if err != nil {
			return nil, fmt.Errorf("new bitmap from image for dpi: %w", err)
		}
		gui.SetImage(bmp)
		return nil, nil
	case ".bmp":
		buf := new(bytes.Buffer)
		_, err := buf.ReadFrom(data)
		if err != nil {
			return nil, fmt.Errorf("buf read from: %w", err)
		}
		var img image.Image
		if string(buf.Bytes()[0:3]) == "DDS" {
			img, err = dds.Decode(data)
			if err != nil {
				return nil, fmt.Errorf("dds.Decode %s: %w", file, err)
			}
		} else {
			img, err = bmp.Decode(data)
			if err != nil {
				return nil, fmt.Errorf("bmp.Decode %s: %w", file, err)
			}
		}

		bmp, err := walk.NewBitmapFromImageForDPI(img, 96)
		if err != nil {
			return nil, fmt.Errorf("new bitmap from image for dpi: %w", err)
		}
		gui.SetImage(bmp)
		return nil, nil
	default:
		return nil, fmt.Errorf("unknown file type %s", ext)
	}
}

func (c *Client) reflectTraversal(inspected interface{}, section string, nest int, index int) {

	v := reflect.ValueOf(inspected)
	tv := v.Type()

	if v.Kind() == reflect.Ptr {
		v = v.Elem()
		tv = v.Type()
	}

	if v.Kind() == reflect.Slice {
		// get name of slice property
		if v.Len() == 0 {
			c.sections[section].Content += fmt.Sprintf("%s- %s: (Empty)\r\n", strings.Repeat("  ", nest), tv.Name())
			//slog.Printf("%s%s (Empty)\n", strings.Repeat("  ", nest), tv.Name())
			return
		}
		c.sections[section].Content += fmt.Sprintf("%s%s:\n", strings.Repeat("  ", nest), tv.Name())
		//slog.Printf("%s%s:", strings.Repeat("  ", nest), tv.Name())
		for i := 0; i < v.Len(); i++ {
			c.reflectTraversal(v.Index(i).Interface(), section, nest+1, i)
		}
		return
	}

	if v.Kind() != reflect.Struct {
		c.sections[section].Content += fmt.Sprintf("%s%v\n", strings.Repeat("  ", nest), v.Interface())
		//slog.Printf("%s%v\n", strings.Repeat("  ", nest), v.Interface())
		return
	}

	for i := 0; i < v.NumField(); i++ {
		// check if field is exported
		if tv.Field(i).PkgPath != "" {
			continue
		}

		// is it a slice?
		if v.Field(i).Kind() == reflect.Slice {
			if nest == 0 {
				section = tv.Field(i).Name
				_, ok := c.sections[section]
				if !ok {
					c.sections[section] = &gui.Section{
						Name:  section,
						Count: 0,
					}
				}
			}
			s := v.Field(i)
			if s.Len() == 0 {
				c.sections[section].Content += fmt.Sprintf("%s- %s: (Empty)\r\n", strings.Repeat("  ", nest), tv.Field(i).Name)
				//slog.Printf("%s%s %s: (Empty)\n", strings.Repeat("  ", nest), indexStr, tv.Field(i).Name)
				continue
			}
			c.sections[section].Count = s.Len()
			c.sections[section].Content += fmt.Sprintf("%s %s\r\n", strings.Repeat("  ", nest), tv.Field(i).Name)
			//slog.Printf("%s%s %s:", strings.Repeat("  ", nest), indexStr, tv.Field(i).Name)

			for j := 0; j < s.Len(); j++ {
				if tv.Field(i).PkgPath != "" {
					continue
				}

				if s.Index(j).Kind() == reflect.Uint8 {
					if j == 0 {
						c.sections[section].Content += fmt.Sprintf("%s", strings.Repeat("  ", nest+1))
						//slog.Printf("%s", strings.Repeat("  ", nest+1))
					}
					//fmt.Printf("0x%02x ", s.Index(j).Interface())
					if j == s.Len()-1 {
						//slog.Println()
					}
					continue
				}
				c.reflectTraversal(s.Index(j).Interface(), section, nest+1, j)
				//slog.Printf("  %d %s\t %+v", j, tv.Field(i).Name, s.Index(j).Interface())
			}
			continue
		}

		if tv.Field(i).Name == "MaterialName" {
			continue
		}
		c.sections[section].Content += fmt.Sprintf("%s %s: %v\r\n", strings.Repeat("  ", nest), tv.Field(i).Name, v.Field(i).Interface())
		//slog.Printf("%s%s %s: %v\n", strings.Repeat("  ", nest), indexStr, tv.Field(i).Name, v.Field(i).Interface())
	}
}

func generateSize(in int) string {
	val := float64(in)
	if val < 1024 {
		return fmt.Sprintf("%0.0f bytes", val)
	}
	val /= 1024
	if val < 1024 {
		return fmt.Sprintf("%0.0f KB", val)
	}
	val /= 1024
	if val < 1024 {
		return fmt.Sprintf("%0.0f MB", val)
	}
	val /= 1024
	if val < 1024 {
		return fmt.Sprintf("%0.0f GB", val)
	}
	val /= 1024
	return fmt.Sprintf("%0.0f TB", val)
}

func generateIcon(name string, data []byte) *walk.Bitmap {
	var err error

	ext := strings.ToLower(filepath.Ext(name))
	defer func() {
		if err != nil {
			slog.Printf("GenerateIcon: %s", err)
			return
		}
	}()

	wBmp := ico.Grab(ext)
	if wBmp != nil && ext != ".unk" {
		return wBmp
	}

	unkImg := ico.Grab(".unk")

	var img image.Image
	if ext == ".dds" {
		img, err = dds.Decode(bytes.NewReader(data))
		if err != nil {
			err = fmt.Errorf("dds.Decode %s: %w", name, err)
			return unkImg
		}
		dst := image.NewRGBA(image.Rect(0, 0, img.Bounds().Max.X/2, img.Bounds().Max.Y/2))
		draw.NearestNeighbor.Scale(dst, image.Rect(0, 0, 16, 16), img, img.Bounds(), draw.Over, nil)

		wBmp, err = walk.NewBitmapFromImageForDPI(dst, 96)
		if err != nil {
			err = fmt.Errorf("new bitmap from image for dpi: %s", err)
			return unkImg
		}
		return wBmp
	}

	if ext == ".png" {
		img, err = png.Decode(bytes.NewReader(data))
		if err != nil {
			err = fmt.Errorf("png.Decode %s: %w", name, err)
			return unkImg
		}
		dst := image.NewRGBA(image.Rect(0, 0, img.Bounds().Max.X/2, img.Bounds().Max.Y/2))
		draw.NearestNeighbor.Scale(dst, image.Rect(0, 0, 16, 16), img, img.Bounds(), draw.Over, nil)

		wBmp, err = walk.NewBitmapFromImageForDPI(dst, 96)
		if err != nil {
			err = fmt.Errorf("new bitmap from image for dpi: %s", err)
			return unkImg
		}
		return wBmp
	}
	if ext == ".bmp" {
		buf := new(bytes.Buffer)
		_, err = buf.ReadFrom(bytes.NewReader(data))
		if err != nil {
			err = fmt.Errorf("buf read from: %w", err)
			return unkImg
		}
		var img image.Image
		if string(buf.Bytes()[0:3]) == "DDS" {
			img, err = dds.Decode(bytes.NewReader(data))
			if err != nil {
				err = fmt.Errorf("dds.Decode %s: %w", name, err)
				return unkImg
			}
		} else {
			img, err = bmp.Decode(bytes.NewReader(data))
			if err != nil {
				err = fmt.Errorf("bmp.Decode %s: %w", name, err)
				return unkImg
			}
		}
		dst := image.NewRGBA(image.Rect(0, 0, img.Bounds().Max.X/2, img.Bounds().Max.Y/2))
		draw.NearestNeighbor.Scale(dst, image.Rect(0, 0, 16, 16), img, img.Bounds(), draw.Over, nil)

		wBmp, err = walk.NewBitmapFromImageForDPI(dst, 96)
		if err != nil {
			err = fmt.Errorf("new bitmap from image for dpi: %w", err)
			return unkImg
		}
		return wBmp
	}

	fmt.Println("unk ext", ext, unkImg)

	return unkImg
}

func (c *Client) wldInspect(file string) (isInspected bool) {

	fileExt := strings.ToLower(filepath.Ext(file))
	if fileExt != ".wld" {
		return
	}
	isInspected = true

	data, err := c.pfs.File(file)
	if err != nil {
		slog.Printf("Failed to open file %s: %s", file, err)
		return
	}
	c.sections[".Info"] = &gui.Section{
		Name:    ".Info",
		Content: "Wld Zone Data",
		Icon:    generateIcon(file, nil),
	}
	wld, err := common.WldOpen(bytes.NewReader(data))
	if err != nil {
		slog.Printf("Failed to open wld %s: %s", file, err)
		return
	}

	for i := uint32(0); i < wld.FragmentCount; i++ {
		data, err := wld.Fragment(int(i))
		if err != nil {
			slog.Printf("Failed to open fragment %d: %s", i, err)
			return
		}

		r := bytes.NewReader(data)
		dec := encdec.NewDecoder(r, binary.LittleEndian)

		fragCode := dec.Int32()
		fragName := common.FragName(int(fragCode))
		_, ok := c.sections[fragName]
		if !ok {
			c.sections[fragName] = &gui.Section{
				Name:    fragName,
				Count:   0,
				Content: "Todo: Actual content",
			}
		}
		c.sections[fragName].Count++
	}

	return true
}
